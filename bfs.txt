# level order traversa; in binary tree using java and using python 

import java.util.LinkedList;
import java.util.Queue;
class TreeNode{
    int val;
    TreeNode left, right;
    TreeNode(int value){
        this.value=value;
        this.left=this.right=null;
    }
}
public class BinaryTreeLevelOrder{
    public void levelorderTraversal(TreeNode root){
        if (root==null){
            return;
        }
        Queue<TreeNode> queue= new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode current=queue.poll();
            System.out.println(current.val+" ");
            if (current.left!=null){
                queue.add(current.left);

            }
            if (current.right!=null){
                queue.add(current.right);
            }

        }
    }
    public static void main(String[] args){
        TreeNode root=new TreeNode(1);
        root.left=new TreeNode(2);
        root.right=new TreeNode(3);
        root.left.left=new TreeNode(4);
        root.left.right=TreeNode(5);
        root.right.left=TreeNode(6);
        root.right.right=TreeNode(7);
        BinaryTreeLevelOrder tree=new BinaryTreeLevelOrder();
        System.out.println("level order traversal:");
        tree.levelOrderTraversal(root);
    }
}

# python implementation

from collection import deque
class TreeNode:
    def __init__(self, val=0, left=None,right=None):
        self.val=val
        self.left=left
        self.right=right
def level_order_traversal(root):
    if not root;
        return
    queue=deque([root])
    while queue:
        current=queue.popleft()
        print(current.val,end=" ")
        if current.left:
            queue.append(current.left)
        if current.right:
            queue.append(current.right)
if __name__="__main__":
    root=TreeNode(1)
    root.left=TreeNode(2)
    root.right=TreeNode(3)
    root.left.left=TreeNode(4)
    root.left.right=TreeNode(5)
    root.right.left=TreeNode(6)
    root.right.right=TreeNode(7)
    print("level-order traversal")
    level_order_traversal(root)


    # iterative preorder traversal in python
    python implementation

    class TreeNode;
        def __init__(self,val=0,left=None,right=None);
            self.val=val
            self.left=left
            self.right=right
    def interastive_preorder_traversal(root):
        if not root:
            return 
        stck=[root]
        while stack:
            current=stack.pop()
            print(current.val," ")
            if current.right:
                stack.append(current.right)
            if current.left:
                stack.append(current.left)
if __name__="__main__":
    root=TreeNode(1)
    root.left=TreeNode(2)
    root.right=TreeNode(3)
    root.left.left=TreeNode(4)
    root.left.right=TreeNode(5)
    root.right.left=TreeNode(6)
    root.right.right=TreeNode(7)
    print("iterative solution ",end=" ")
    iterative-preorser_traversal(root)


java implementation 
import java.util.Stack;
class TreeNode{
        int val;
        Treenode left,  right;
        TreeNode(int val){
            this.val=val;
            this.left=this.right=null;

        }

}
public class BinaryTreePreorder{
    public void iterativePreorderTraversal(Treenode root){
        if (root==null){
            return;
        }
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode current=stack.pop();
            System.ot.println(current.val+" ");
            if (current.right!=null){
                stack.push(current.right);

            }
            if (current.left!=null){
                stack.push(current.left);
            }
        }
   }
   public static void main(String[] args){
    TreeNode root=new TreeNode(1);
    root.left=new TreeNode(2);
    root.right=new TreeNode(3);
    root.left.left=new TreeNode(4);
    root.left.right=new TreeNode(5);
    root.right.left=TreeNode(6);
    root.right.right=TreeNode(7);
    BinaryTreePreorder tree=new BinaryTreePreorder();
    System.out.println("interative preorder traversal ");
    tree.iterativePreorderTraversal(root);
   }
}
